"""
Задание 2. Массив размером 2m + 1, где m – натуральное число,
заполнен случайным образом. Найдите в массиве медиану.
Медианой называется элемент ряда, делящий его на
две равные по длине части:
в одной находятся элементы,
которые не меньше медианы,
в другой – не больше медианы.
Решите задачу тремя способами:
3) с помощью встроенной функции поиска медианы
сделайте замеры на массивах длиной 10, 100, 1000 элементов
В конце сделайте аналитику какой трех из способов оказался эффективнее
"""
from random import randint
from timeit import timeit
from statistics import median

a = [randint(0, 1000) for i in range(11)]
b = [randint(0, 1000) for i in range(101)]
c = [randint(0, 1000) for i in range(1001)]
# d = [randint(0, 1000) for i in range(100)]

print('Время поиска медианы функцией median в массиве из 11 элементов:')
print(timeit("median(a[:])", globals=globals(), number=100), end='\n\n')
# 5.1999999999996493e-05
print('Время поиска медианы функцией median в массиве из 101 элементов:')
print(timeit("median(b[:])", globals=globals(), number=100), end='\n\n')
# 0.00032409999999999384
print('Время поиска медианы функцией median в массиве из 1001 элементов:')
print(timeit("median(c[:])", globals=globals(), number=100), end='\n\n')
# 0.0076343999999999995
# print(median(d))

# Вполне предсказуемо лидером стал вариант с использованием встроенной функции median() модуля statistics. На втором
# месте вариант поиска медианы без предварительной сортировки, опять же скорее всего за счет использования встроенной
# функции max(), которая также довольно оптимизирована по скорости. С серьезным отставанием идет вариант поиска медианы
# с предварительной гномьей сортировкой, хотя данный алгоритм сортировки использует всего лищь один цикл, что есть
# хорошо и для сортировок как правило несвойственно.
